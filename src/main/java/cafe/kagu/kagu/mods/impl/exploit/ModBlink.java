/**
 * 
 */
package cafe.kagu.kagu.mods.impl.exploit;

import java.util.ArrayList;
import java.util.Collections;
import java.util.concurrent.CopyOnWriteArrayList;

import javax.vecmath.Vector3d;

import cafe.kagu.kagu.eventBus.EventHandler;
import cafe.kagu.kagu.eventBus.Handler;
import cafe.kagu.kagu.eventBus.impl.EventPacketReceive;
import cafe.kagu.kagu.eventBus.impl.EventPacketSend;
import cafe.kagu.kagu.eventBus.impl.EventTick;
import cafe.kagu.kagu.mods.Module;
import cafe.kagu.kagu.mods.ModuleManager;
import cafe.kagu.kagu.settings.impl.BooleanSetting;
import cafe.kagu.kagu.settings.impl.IntegerSetting;
import cafe.kagu.kagu.utils.ChatUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.network.Packet;
import net.minecraft.network.play.INetHandlerPlayClient;
import net.minecraft.network.play.INetHandlerPlayServer;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.client.C02PacketUseEntity.Action;
import net.minecraft.network.play.client.C03PacketPlayer;

/**
 * @author lavaflowglow
 *
 */
public class ModBlink extends Module {
	
	public ModBlink() {
		super("Blink", Category.EXPLOIT);
		setSettings(blinkSentPackets, blinkReceivedPackets, backtrackCompatibility);
	}
	
	private BooleanSetting blinkSentPackets = new BooleanSetting("Blink Sent Packets", true);
	private BooleanSetting blinkReceivedPackets = new BooleanSetting("Blink Received Packets", false);
	private BooleanSetting backtrackCompatibility = (BooleanSetting) new BooleanSetting("Backtrack Compatibility Mode", false).setDependency(blinkSentPackets::isEnabled);
	
	private CopyOnWriteArrayList<Packet<INetHandlerPlayClient>> sentPackets = new CopyOnWriteArrayList<>();
	private CopyOnWriteArrayList<Packet<INetHandlerPlayServer>> receivedPackets = new CopyOnWriteArrayList<>();
	
	@Override
	public void onDisable() {
		sendQueue();
	}
	
	@EventHandler
	private Handler<EventPacketSend> onPacketSend = e -> {
		if (e.isPost())
			return;
		
		// Backtrack
		if (blinkSentPackets.isEnabled()) {
			if (backtrackCompatibility.isEnabled() && !backtrackCompatibility.isHidden()) {
				if (e.getPacket() instanceof C02PacketUseEntity && ((C02PacketUseEntity)e.getPacket()).getAction() == Action.ATTACK) {
					
					C02PacketUseEntity c02 = (C02PacketUseEntity)e.getPacket();
					
					skip:{
						try {
							int cutoffTicks = ModuleManager.modBacktrack.getBacktrackBlinkTickOverride();
							Vector3d[] backs = ModuleManager.modBacktrack.getBacktracks().get(c02.getEntityFromWorld(mc.theWorld));
							if (backs == null) {
								break skip;
							}
							ModuleManager.modBacktrack.getBacktracks().clear();
							for (int i = backs.length - 1; i >= 0; i--) {
								if (i >= cutoffTicks) {
									backs[i] = null;
								}
							}
							ModuleManager.modBacktrack.getBacktracks().put((EntityLivingBase) c02.getEntityFromWorld(mc.theWorld), backs);
						} catch (Exception e2) {
							e2.printStackTrace();
						}
					}
					
					int movementPackets = 0;
					ArrayList<Packet<INetHandlerPlayClient>> remove = new ArrayList();
					ArrayList<Packet<INetHandlerPlayClient>> sent = new ArrayList(sentPackets);
					Collections.reverse(sent);
					for (Packet p : sent) {
						if (movementPackets > ModuleManager.modBacktrack.getBacktrackBlinkTickOverride()) {
							remove.add(p);
						}else if (p instanceof C03PacketPlayer) {
							movementPackets++;
						}
					}
					Collections.reverse(remove);
					remove.forEach(mc.getNetHandler().getNetworkManager()::sendPacketNoEvent);
					sentPackets.removeAll(remove);
					ModuleManager.modBacktrack.setBacktrackBlinkTickOverride(ModuleManager.modBacktrack.getBacktrackTicks().getValue());
					return;
				}else if (e.getPacket() instanceof C03PacketPlayer && ((C03PacketPlayer)e.getPacket()).isMoving()) {
					int movementPackets = 1;
					ArrayList<Packet<INetHandlerPlayClient>> remove = new ArrayList();
					ArrayList<Packet<INetHandlerPlayClient>> sent = new ArrayList(sentPackets);
					Collections.reverse(sent);
					for (Packet p : sent) {
						if (movementPackets > ModuleManager.modBacktrack.getBacktrackTicks().getValue()) {
							remove.add(p);
						}else if (p instanceof C03PacketPlayer) {
							movementPackets++;
						}
					}
					Collections.reverse(remove);
					remove.forEach(mc.getNetHandler().getNetworkManager()::sendPacketNoEvent);
					sentPackets.removeAll(remove);
				}
			}
			
			// Blink
			try {
				sentPackets.add((Packet<INetHandlerPlayClient>) e.getPacket());
				e.cancel();
			} catch (Exception e2) {
				
			}
		}
	};
	
	@EventHandler
	private Handler<EventPacketReceive> onPacketReceived = e -> {
		if (e.isPost())
			return;
		
		if (blinkReceivedPackets.isEnabled()) {
			try {
				receivedPackets.add((Packet<INetHandlerPlayServer>) e.getPacket());
				e.cancel();
			} catch (Exception e2) {
				
			}
		}
	};
	
	@EventHandler
	private Handler<EventTick> onTick = e -> {
		if (e.isPost())
			return;
		setInfo(sentPackets.size() + "", receivedPackets.size() + "");
		if (mc.thePlayer.isDead)
			sendQueue();
	};
	
	/**
	 * Sends the blink queue and then clears it
	 */
	public void sendQueue() {
		try {
			sentPackets.forEach(mc.getNetHandler().getNetworkManager()::sendPacketNoEvent);
		} catch (Exception e) {
			
		}
		sentPackets.clear();
		try {
			INetHandlerPlayServer packetListener = (INetHandlerPlayServer)mc.getNetHandler().getNetworkManager().getPacketListener();
			receivedPackets.forEach(e -> e.processPacket(packetListener));
		} catch (Exception e) {
			
		}
		receivedPackets.clear();
	}
	
	/**
	 * @return the backtrackCompatibility
	 */
	public BooleanSetting getBacktrackCompatibility() {
		return backtrackCompatibility;
	}
	
	/**
	 * @return the sentPackets
	 */
	public CopyOnWriteArrayList<Packet<INetHandlerPlayClient>> getSentPackets() {
		return sentPackets;
	}
	
}
