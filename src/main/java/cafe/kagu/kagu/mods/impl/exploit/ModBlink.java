/**
 * 
 */
package cafe.kagu.kagu.mods.impl.exploit;

import java.util.ArrayList;
import java.util.Collections;
import java.util.concurrent.CopyOnWriteArrayList;

import javax.vecmath.Vector3d;

import cafe.kagu.kagu.Kagu;
import cafe.kagu.kagu.eventBus.EventHandler;
import cafe.kagu.kagu.eventBus.Handler;
import cafe.kagu.kagu.eventBus.impl.EventPacketReceive;
import cafe.kagu.kagu.eventBus.impl.EventPacketSend;
import cafe.kagu.kagu.eventBus.impl.EventTick;
import cafe.kagu.kagu.mods.Module;
import cafe.kagu.kagu.mods.ModuleManager;
import cafe.kagu.kagu.mods.impl.combat.ModBacktrack;
import cafe.kagu.kagu.settings.impl.BooleanSetting;
import cafe.kagu.kagu.settings.impl.DoubleSetting;
import cafe.kagu.kagu.settings.impl.IntegerSetting;
import cafe.kagu.kagu.utils.ChatUtils;
import cafe.kagu.kagu.utils.TimerUtil;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.network.Packet;
import net.minecraft.network.play.INetHandlerPlayClient;
import net.minecraft.network.play.INetHandlerPlayServer;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.client.C02PacketUseEntity.Action;
import net.minecraft.network.play.client.C03PacketPlayer;

/**
 * @author lavaflowglow
 *
 */
public class ModBlink extends Module {
	
	public ModBlink() {
		super("Blink", Category.EXPLOIT);
		setSettings(blinkSentPackets, blinkReceivedPackets, backtrackCompatibility, enableLagSwitch, lagSwitchDelay);
	}
	
	private BooleanSetting blinkSentPackets = new BooleanSetting("Blink Sent Packets", true);
	private BooleanSetting blinkReceivedPackets = new BooleanSetting("Blink Received Packets", false);
	private BooleanSetting backtrackCompatibility = (BooleanSetting) new BooleanSetting("Backtrack Compatibility Mode", false).setDependency(blinkSentPackets::isEnabled);
	private BooleanSetting enableLagSwitch = new BooleanSetting("Lag Switch", false);
	private IntegerSetting lagSwitchDelay = new IntegerSetting("Lag Switch Delay", 500, 0, 2000, 50).setDependency(enableLagSwitch::isEnabled);
	
	private CopyOnWriteArrayList<Packet<INetHandlerPlayClient>> sentPackets = new CopyOnWriteArrayList<>();
	private CopyOnWriteArrayList<Packet<INetHandlerPlayClient>> receivedPackets = new CopyOnWriteArrayList<>();
	private TimerUtil lagSwitchTimerUtil = new TimerUtil();
	
	@Override
	public void onDisable() {
		sendQueue();
	}
	
	@EventHandler
	private Handler<EventPacketSend> onPacketSend = e -> {
		if (e.isPost())
			return;
		
		// Backtrack
		if (blinkSentPackets.isEnabled()) {
			if (backtrackCompatibility.isEnabled() && !backtrackCompatibility.isHidden()) {
				if (e.getPacket() instanceof C02PacketUseEntity && ((C02PacketUseEntity)e.getPacket()).getAction() == Action.ATTACK) {
					
					C02PacketUseEntity c02 = (C02PacketUseEntity)e.getPacket();
					
					skip:{
						try {
							int cutoffTicks = Kagu.getModuleManager().getModule(ModBacktrack.class).getBacktrackBlinkTickOverride();
							Vector3d[] backs = Kagu.getModuleManager().getModule(ModBacktrack.class).getBacktracks().get(c02.getEntityFromWorld(mc.theWorld));
							if (backs == null) {
								break skip;
							}
							Kagu.getModuleManager().getModule(ModBacktrack.class).getBacktracks().clear();
							for (int i = backs.length - 1; i >= 0; i--) {
								if (i >= cutoffTicks) {
									backs[i] = null;
								}
							}
							Kagu.getModuleManager().getModule(ModBacktrack.class).getBacktracks().put((EntityLivingBase) c02.getEntityFromWorld(mc.theWorld), backs);
						} catch (Exception e2) {
							e2.printStackTrace();
						}
					}
					
					int movementPackets = 0;
					ArrayList<Packet<INetHandlerPlayClient>> remove = new ArrayList();
					ArrayList<Packet<INetHandlerPlayClient>> sent = new ArrayList(sentPackets);
					Collections.reverse(sent);
					for (Packet p : sent) {
						if (movementPackets > Kagu.getModuleManager().getModule(ModBacktrack.class).getBacktrackBlinkTickOverride()) {
							remove.add(p);
						}else if (p instanceof C03PacketPlayer) {
							movementPackets++;
						}
					}
					Collections.reverse(remove);
					remove.forEach(mc.getNetHandler().getNetworkManager()::sendPacketNoEvent);
					sentPackets.removeAll(remove);
					Kagu.getModuleManager().getModule(ModBacktrack.class).setBacktrackBlinkTickOverride(Kagu.getModuleManager().getModule(ModBacktrack.class).getBacktrackTicks().getValue());
					return;
				}else if (e.getPacket() instanceof C03PacketPlayer && ((C03PacketPlayer)e.getPacket()).isMoving()) {
					int movementPackets = 1;
					ArrayList<Packet<INetHandlerPlayClient>> remove = new ArrayList();
					ArrayList<Packet<INetHandlerPlayClient>> sent = new ArrayList(sentPackets);
					Collections.reverse(sent);
					for (Packet p : sent) {
						if (movementPackets > Kagu.getModuleManager().getModule(ModBacktrack.class).getBacktrackTicks().getValue()) {
							remove.add(p);
						}else if (p instanceof C03PacketPlayer) {
							movementPackets++;
						}
					}
					Collections.reverse(remove);
					remove.forEach(mc.getNetHandler().getNetworkManager()::sendPacketNoEvent);
					sentPackets.removeAll(remove);
				}
			}
			
			// Blink
			try {
				if (e.isCanceled())
					return;
				sentPackets.add((Packet<INetHandlerPlayClient>) e.getPacket());
				e.cancel();
			} catch (Exception e2) {
				
			}
		}
	};
	
	@EventHandler
	private Handler<EventPacketReceive> onPacketReceived = e -> {
		if (e.isPost())
			return;
		
		if (blinkReceivedPackets.isEnabled()) {
			try {
				if (e.isCanceled())
					return;
				receivedPackets.add((Packet<INetHandlerPlayClient>) e.getPacket());
				e.cancel();
			} catch (Exception e2) {
				
			}
		}
	};
	
	@EventHandler
	private Handler<EventTick> onTick = e -> {
		if (e.isPost())
			return;
		
		if (enableLagSwitch.isEnabled() && lagSwitchTimerUtil.hasTimeElapsed(lagSwitchDelay.getValue(), true))
			sendQueue();
		
		setInfo(sentPackets.size() + "", receivedPackets.size() + "");
		if (mc.thePlayer.isDead)
			sendQueue();
	};
	
	/**
	 * Sends the blink queue and then clears it
	 */
	public void sendQueue() {
		if (!mc.isSingleplayer())
			try {
				sentPackets.forEach(mc.getNetHandler().getNetworkManager()::sendPacketNoEvent);
			} catch (Exception e) {
				
			}
		sentPackets.clear();
		if (!mc.isSingleplayer())
			try {
				INetHandlerPlayClient packetListener = (INetHandlerPlayClient)mc.getNetHandler().getNetworkManager().getNetHandler();
				receivedPackets.forEach(e -> e.processPacket(packetListener));
			} catch (Exception e) {
				e.printStackTrace();
			}
		receivedPackets.clear();
	}
	
	/**
	 * @return the backtrackCompatibility
	 */
	public BooleanSetting getBacktrackCompatibility() {
		return backtrackCompatibility;
	}
	
	/**
	 * @return the sentPackets
	 */
	public CopyOnWriteArrayList<Packet<INetHandlerPlayClient>> getSentPackets() {
		return sentPackets;
	}
	
}
